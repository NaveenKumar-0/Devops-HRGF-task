name: CI/CD Pipeline

# Trigger pipeline on push to main branch
on:
  push:
    branches: [main]


# Define reusable secrets for DockerHub and Kubernetes
permissions:
  contents: read

env:
  IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/hello-world
  AWS_REGION: ${{ secrets.AWS_REGION }}
  EKS_CLUSTER_NAME: ${{ secrets.EKS_CLUSTER_NAME }}
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

jobs:
  # Job 1: Continuous Integration
  ci:
    name: CI - Build, Test & Scan
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.set-version.outputs.tag }}
    steps:
      # Checkout code
      - name: Checkout Code
        uses: actions/checkout@v4

      # Setup Node.js
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 18

      # Install dependencies
      - name: Install Dependencies
        run: npm install
        working-directory: app
        
      - name: Run linting
        run: npm run lint
        working-directory: app

      # Run tests
      - name: Run Tests
        run: npm test || echo "No tests defined"
        working-directory: app

      # Determine version from VERSION file
      - name: Read VERSION file
        id: set-version
        run: |
          VERSION=$(cat VERSION)
          echo "TAG=v${VERSION}" >> $GITHUB_ENV
          echo "::set-output name=tag::v${VERSION}"

      # Build Docker image
      - name: Build Docker Image
        run: |
          docker build -t $IMAGE_NAME:${{ steps.set-version.outputs.tag }} ./app
          docker tag $IMAGE_NAME:${{ steps.set-version.outputs.tag }} $IMAGE_NAME:latest

      # Scan image with Trivy
      - name: Trivy Security Scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_NAME }}:${{ steps.set-version.outputs.tag }}
          format: 'table'
          exit-code: '0'
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'

      # Login to DockerHub
      - name: DockerHub Login
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Push image
      - name: Push Docker Image
        run: |
          docker push $IMAGE_NAME:${{ steps.set-version.outputs.tag }}
          docker push $IMAGE_NAME:latest

  # Job 2: Continuous Deployment
  cd:
    name: CD - Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: ci
    steps:
      # Checkout code (needed for manifests)
      - name: Checkout Code
        uses: actions/checkout@v4

      # Install kubectl
      - name: Install Kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      #  AWS CLI 
      - name: AWS CLI vesion
        run: |
          aws --version

      # Update kubeconfig for EKS cluster
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME

      # Set image tag from CI job
      - name: Set Image Tag
        run: echo "IMAGE_TAG=${{ needs.ci.outputs.image-tag }}" >> $GITHUB_ENV

      # Apply manifests using Kustomize (production)
      - name: Deploy to Kubernetes
        run: |
          kubectl apply -k kustomize/base

      # Slack notification
      - name: Set timestamp
        run: echo "TIMESTAMP=$(date +%s)" >> $GITHUB_ENV

      - name: Notify Slack
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          fields: workflow,job,commit,repo,ref,author,took
          custom_payload: |
            {
              attachments: [{
                color: '${{ job.status }}' === 'success' ? 'good' : 'danger',
                text: "Deployment complete!\nImage: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}",
                footer: "CI/CD Pipeline",
                ts: ${{ env.TIMESTAMP }}
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/hello-world
          kubectl get pods\

      - name: Run smoke tests
        run: |
          kubectl get service hello-world
          ELB_HOST=$(kubectl get ingress hello-world-ingress -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "ELB hostname: $ELB_HOST"
          curl http://$ELB_HOST
          
  observablitiy:
    runs-on: ubuntu-latest
    uses: NaveenKumar-0/Devops-HRGF-task/.github/workflows/observability.yaml@main
    needs: cd
    with:
      aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
      aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      aws_region: ${{ secrets.AWS_REGION }}
      eks_cluster_name: ${{ secrets.EKS_CLUSTER_NAME }}
